# ***PROBLEM STATEMENT***

# Create an iperf like application using the above 
# developed echo client and server program. Reduce the interval 
# between two consecutive UDP echo packets generated by client 
# to increase the number of echo packets sent from client for a 
# given packet size. Calculate the throughput and average delay 
# observed every one second. Plot the observed throughput and 
# average delay vs time (1 second interval).


# The code for the client starts here
import socket
import sys
import time
import datetime
import argparse
import matplotlib.pyplot as matplotplt


# # Input the required parameters using the normal input method
# totalMessages = int(input("Enter the total number of packets: "))
# messageInterval = float(input("Enter the Interval size: "))
# packetSize = int(input("Enter the Packet size: "))

# Input the required parameters using the argparse method
parser = argparse.ArgumentParser()
parser.add_argument("-n", "--total-number-of-packets", help="Enter the total number of packets", type=int, dest="total_messages")
parser.add_argument("-i", "--interval", help="Enter the Interval size", type=float, dest="message_interval")
parser.add_argument("-s", "--size", help="Enter the Packet size", type=int, dest="packet_size")
args = parser.parse_args()

# Begin with a display message
print('''
**************************************************************
*                       WELCOME!                             *
*                 This is the Client                         *
**************************************************************
''')

# Assign the values obtained from the ArgumentParser
totalMessages = args.total_messages
messageInterval = args.message_interval
packetSize = args.packet_size

# Since window size is same as packetSize, we can use the same value for window size
bufferSize = packetSize

messageFromClient = "This is a message from Client"
serverIP = '127.0.0.1'
serverPort = 20001
socketAddress = (serverIP, serverPort)
bytesToSend = str.encode(messageFromClient) # client message encoded

avgRTT = 0 # Initializing the average RTT
packetSuccessCount = 0 # Initializing the success count of packets

# Creation of UDP Socket on Client's Side for IPv4 family
UDPSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)

# We also set  a standard timeout of 1 second which works when there is a packet loss
UDPSocket.settimeout(1)

# Calibrating the buffer size
# To adjust the window size, we send the message to the server with ADJ denoting Adjustment
calibrationMessage = str.encode(f"ADJ {packetSize}")
print("Calibrating the buffer size...\n")

# Sending the message to the server
UDPSocket.sendto(calibrationMessage, socketAddress)

# Receiving the ACK message from the server
recievedACK = UDPSocket.recvfrom(bufferSize)

# Creation of function which make the application like iperf
# We reduce the input interval to 90% of its initial input value
def iperfInterval(messageInterval):
    lostInterval = messageInterval/10
    return messageInterval - lostInterval # 90% of the initial input value

# For plotting the graph of average throughput, we create an array to store average throughput values for every second
AVERAGEThroughput = []

# For plotting the graph of average throughput, we create an array to store average delay values for every second
AVERAGEDelay = []

# We also create an array to store the time values for the graph
timeValues = []

secondsPassed = 0 # Initializing the seconds passed
delayDiff = 0 # Initializing the delay difference for storing the delay time before transmission of a packet in the next second

# Loop begins here for sending the messages to the server iteratively and increase the time
while totalMessages > 0:
    
    secondsPassed += 1 # Incrementing the seconds passed
    print("\n              ***\n")
    print(f"Time passed: {secondsPassed} seconds")

    # Variable for storing average delay time
    averageDelayTime = 0

    startTimeStamp = datetime.datetime.now().timestamp() # Getting the current time stamp for beginning of the second

    # As long as we don't reach 1 second from the stratTimeStamp, we keep sending the message
    while datetime.datetime.now().timestamp() - startTimeStamp <=1:

        # If delay differnce exceeds 1, we  sleep for the second and don't send the message 
        if delayDiff > 1:
             goToSleep = 1
             delayDiff -= 1
             print("\nPacket is not sent in this second\n")
        
        else:

            goToSleep = delayDiff # If delay difference is less than 1, we send the message
        
        # Sleep till the dalay is over 
        time.sleep(goToSleep)

        if totalMessages == 0:
            break

        # Stop the transfer for the second if we skiped the whole second
        if goToSleep == 1:
            break

        # Send message to the server 
        clientMessage = "Message from the Client"
        UDPSocket.sendto(str.encode(clientMessage), socketAddress)

        # Initialize a variable for storing the sending Timestamp of the echo message
        sendingTimeStamp = datetime.datetime.now().timestamp()

        #Message is sent so, decrease the total number of messages
        totalMessages -= 1

        # Receive the ACK message from the server
        try:
            recievedACK = UDPSocket.recvfrom(bufferSize)
            recievedACK = recievedACK[0]
            recievedACK = recievedACK.decode()
            print(f"\nACK received from the server: {recievedACK}")
        
        # If the packet is not recieved from the server
        # When packet loss occurs causing socket timeout
        except socket.timeout:
            print("\nPACKET LOST!!\n")
            continue # Move on to the next packet

        # Store the recieving timestamp of the ACK message
        recievingTimeStamp = datetime.datetime.now().timestamp()

        # Calculate the RTT
        RTT = recievingTimeStamp - sendingTimeStamp

        # Packet was successfully sent so, increment the packet success count
        packetSuccessCount += 1

        # Average Dealy occurs due to RTT so, increament the average delay between
        averageDelayTime += RTT

        # Define sleepTime for the case when packet arrives earlier than the interval
        # We need to sleep for the interval left to send the next packet
        sleepTime = max(messageInterval - RTT,0)

        # Every iteration, we decrese the interval according to the function we defined earlier to make it like iperfIterval
        messageInterval = iperfInterval(messageInterval)

        passedTime = datetime.datetime.now().timestamp() - startTimeStamp # Calculate the passed time

        # we wait until the interpacket message interval is completed
        # If time isleft, sleep for the remaining time
        if passedTime > 1:
            delayDiff = goToSleep # Store the remaining delay to carry to next second
            break

        elif passedTime + sleepTime > 1 and passedTime <= 1:
            goToSleep = 1-passedTime # Store the sleep value to the rest of the second
            delayDiff = sleepTime - (1 - passedTime) # Store the remaining delay to carry to next second

        else:
            goToSleep = sleepTime # Store the sleep value to the rest of the second

        #Sleep until the delay is complete
        time.sleep(goToSleep)

    # Calculation of the average delay time
    if packetSuccessCount != 0:
        averageDelayTime = averageDelayTime/packetSuccessCount
    
    else:
        averageDelayTime = 0 # If no packet was successfully sent, average delay is 0

    # Calculation of the average throughput
    # We calculate the average throughput by dividing the total data sent by the total number of seconds
    # SInce we are calculating the average throughput for every second, we don't divide by 1 everytime   
    # Since the packet is transfered from client ot server and then back to client, we multiply it by 2 
    averageThroughput = (packetSuccessCount*bufferSize)*2

    print(f"\nAverage Delay: {averageDelayTime} seconds")
    print(f"Average Throughput: {averageThroughput} bytes/second\n")

    # Appending the average delay and throughput values to the array
    AVERAGEDelay.append(averageDelayTime)
    AVERAGEThroughput.append(averageThroughput)

    # Since the value of average delay and average throughput remains same for one second, we append both the values twice
    AVERAGEDelay.append(averageDelayTime)
    AVERAGEThroughput.append(averageThroughput)

    timeValues.append(secondsPassed)
    timeValues.append(secondsPassed + 0.9999999999999999) # this time value stays same till the end of the second

# The graph of average throughput and average delay is plotted here
# We create two subgraphs side by side 

# 1. Sub Plot for the graph of average throughput
matplotplt.subplot(1,2,1)

# Average throughput is on Y-axis and time is on X-axis
matplotplt.plot(timeValues, AVERAGEThroughput, color = 'blue', label = 'Average Throughput')
matplotplt.xlabel('Time (seconds)')
matplotplt.ylabel('Average Throughput (bytes/second)')
matplotplt.title('Average Throughput Plot')

# 2. Sub Plot for the graph of average delay
matplotplt.subplot(1,2,2)

# Average Delay is on Y-axis and time is on X-axis
matplotplt.plot(timeValues, AVERAGEDelay, color = 'red', label = 'Average Delay')
matplotplt.xlabel('Time (seconds)')
matplotplt.ylabel('Average Delay (seconds)')
matplotplt.title('Average Delay Plot')

matplotplt.show()

print('\n Graph is plotted!')
print('\n Exiting the program and terminating the connection ...\n')

# Send the message to the server to terminate the connection
UDPSocket.sendto(str.encode("TERMINATE"), socketAddress)
serverResponse = UDPSocket.recvfrom(bufferSize)
print(f"Message from the server: Connection Terminated")
print("\n    ------------------------------------")
print("\n")

# TERMINATE the socket
UDPSocket.close()
